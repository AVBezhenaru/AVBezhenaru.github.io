---
layout: page
title: Грокаем алгоритмы
description: автор Aditya Y. Bhargava
img: /assets/img/grok.jpg
---
#### Краткий конспект


### Глава 1. Знакомство с алгоритмами.

Алгоритм - набор инструкций для выполнения некоторой задачи

Бинарный поиск(двоичный поиск) - это алгоритм поиска элемента в атсортированном списке, использующий деление списка на половину.
[Реализация на python](https://github.com/AVBezhenaru/grokkingAlgorithms/blob/master/binarySearch/binarySearch.py)

#### О-большое

Специальная нотация "О-болъшое" описывает скорость работы алгоритма.

1. Скорость алгоритмов измеряется не в секундах, а в темпе роста количества операций. 
2. По сути формула описывает, насколько быстро возрастает время выполнения алгоритма с увеличением размера входных данных. 
3. Время выполнения алгоритмов выражается как «О-большое». 
4. Время выполнения O(log n) быстрее О(n), а с увеличением размера списка, в котором ищется значение, оно становится намного быстрее.

Типичные примеры «О-большого» 

1. O(log n ), или логарифмическое время. Пример: бинарный поиск. 
2. О(n), или линейное время. Пример: простой поиск. 
3. О(n * log n). Пример: эффективные алгоритмы сортировки (быстрая сортировка). 
4. О(n2). Пример: медленные алгоритмы сортировки (сортировка выбором). 
5. О(n!). Пример: очень медленные алгоритмы (задача о коммивояжере)

Существуют и другие варианты времени выполнения, но эти пять встре
чаются чаще всего. 


### Глава 2. Сортировка выбором

[Реализация на python](https://github.com/AVBezhenaru/grokkingAlgorithms/blob/master/sortByChoice/sortByChoice.py)

1. Если вам потребуется сохранить набор элементов, воспользуйтесь массивом или списком. 
2. В массиве все элементы хранятся в памяти рядом друг с другом. 
3. В списке элементы распределяются в произвольных местах памяти, при этом в одном элементе хранится адрес следующего элемента. 
4. Массивы обеспечивают быстрое чтение. 
5. Списки обеспечивают быструю вставку и выполнение. 
6. Все элементы массива должны быть однотипными (только целые числа, только вещественные числа и т. д.).


### Глава 3. Рекурсия

Рекурсией называется такая конструкция, при которой функция вызывает саму себя.

#### Базовый случай и рекурсивныи случай

Так как рекурсивная функция вызывает сауа себя, программисту легко ошибиться и написать функцию так, что возникнет бесконечный цикл.
Когда вы пишете рекурсивную функцию, в ней необходимо указать, в какой момент следует прервать рекурсию. Вот почему каждая рекурсивная функция состоит из двух частей: базового случая и рекурсивного случая. В рекурсивном случае функция вызывает саму себя. В базовом случае функция себя не вызывает". чтобы предотвратить зацикливание.

#### Стек

Стек (англ. stack — стопка; читается стэк) — абстрактный тип данных, представляющий собой список элементов, организованных по принципу LIFO (англ. last in — first out, «последним пришёл — первым вышел»).
Стек поддерживает две операции: занесение и извлечение элементов. 

Во внутренней работе вашего компьютера используется стек, называемый стеком вызовов.

Стек вызов - LIFO-стек, хранящий информацию для возврата управления из подпрограмм в программу

Все вызовы функций сохраняются в стеке вызовов.


### Глава 4. Быстрая сортировка

